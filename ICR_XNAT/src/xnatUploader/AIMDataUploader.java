/********************************************************************
* Copyright (c) 2012, Institute of Cancer Research
* All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 
* (1) Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
* 
* (2) Redistributions in binary form must reproduce the above
*     copyright notice, this list of conditions and the following
*     disclaimer in the documentation and/or other materials provided
*     with the distribution.
* 
* (3) Neither the name of the Institute of Cancer Research nor the
*     names of its contributors may be used to endorse or promote
*     products derived from this software without specific prior
*     written permission.
* 
* THIS SOFTWARE IS PROVIDED BY XXHE COPYRIGHT HOLDERS AND CONTRIBUTORS
* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*********************************************************************/

/*********************************************************************
* @author Simon J Doran
* Java class: MRIWDataUploader.java
* First created on Nov 15, 2010 at 3:00:38 PM
* 
* Object for uploading files to XNAT that have been generated by the
* in-house ICR application MRIW.
*********************************************************************/

package xnatUploader;

/**
 *
 * @author Simon J Doran
 *
 * Java class: MRIWDataUploader.java
 *
 * First created on Nov 15, 2010 at 3:00:38 PM
 *
 */
import xnatUploader.RTStructureSetUploader;
import com.generationjava.io.xml.SimpleXmlWriter;
import dataRepresentations.xnatUpload.AIMOutput;
import dataRepresentations.xnatUpload.MRIWOutput;
import dataRepresentations.RTStruct_old;
import etherj.XmlException;
import etherj.aim.ImageAnnotationCollection;
import etherj.aim.XmlParser;
import exceptions.DataFormatException;
import exceptions.XMLException;
import exceptions.XNATException;
import generalUtilities.UIDGenerator;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.logging.Level;
import javax.imageio.ImageIO;
import org.apache.log4j.Logger;
import org.dcm4che2.data.DicomObject;
import org.dcm4che2.data.TransferSyntax;
import org.dcm4che2.io.DicomOutputStream;
import org.w3c.dom.Document;
import xmlUtilities.DelayedPrettyPrinterXmlWriter;
import xnatDAO.XNATGUI;
import xnatDAO.XNATProfile;
import xnatRestToolkit.XnatResource;


public class AIMDataUploader extends QCAssessmentDataUploader
{
   static    Logger                        logger = Logger.getLogger(AIMDataUploader.class);
   protected ImageAnnotationCollection     iac;
	protected AIMOutput                     aim;
   protected LinkedHashMap<String, String> simpleEntries;

   public AIMDataUploader(XNATProfile xnprf)
   {
      super(xnprf);
      
      // "Simple" in the sense that no special processing needs to be performed
      // to set these in the user interface once their values are available. I'm
      // unhappy that there is duplication (and hence the need to maintain
      // consistency) here of data in searchableXNATElements.xml,
      // but it is not obvious how to select just the elements we want without
      // typing all the names anyway!
      simpleEntries = new LinkedHashMap<String, String>();
      simpleEntries.put("Modality name",         "modality");
      simpleEntries.put("Modality subtype",      "subtype");
   }

  /**
    * Open and read the specified file.
    * Note that the default type of file is XML, but this method will be over-
    * ridden in subclasses to allow us to open arbitrary file types, such as
    * DICOM.
    * @return a boolean variable with true if the file was opened successfully
    *         and false otherwise.
    */
	@Override
   public boolean readFile()
   {
		ImageAnnotationCollection iac;
		try
		{
			iac = XmlParser.parse(uploadFile);
		}
		catch (XmlException | IOException ex)
		{
			String msg = "Problem reading AIM instance file: " + ex.getMessage();
			logger.error(msg);
			errorOccurred = true;
         errorMessage  = msg;
			return false;
		}

      return true;				
   }
	
	/**
    * Parse an AIM instance to extract the relevant metadata.
	 * Note that because an external library Ether is being used, most of the
	 * parsing of the XML is actually performed in etherj.aim.XmlParser.
	 * The transformation of the etherj.aim.ImageAnnotationCollection to an
	 * AIMOutput DataRepresentation occurs in the relevant constructor called
	 * here. This method extracts the variables that are needed by the uploader.
	 * @return true if the parsing is successful, false otherwise.
    */
	@Override
   public boolean parseFile()
   {     
      try
      {
         aim = new AIMOutput(iac, xnprf);
         
 //        date = convertToXNATDate(aim.prov.creationDateTime);
 //        time = convertToXNATTime(aim.prov.creationDateTime);
         
         XNATProject      = aim.XNATProjectID; 
         XNATSubjectID    = aim.XNATSubjectID;
         XNATExperimentID = aim.XNATExperimentID;
         XNATScanIdSet    = aim.XNATScanID;
         
         populateStringFields();
         
      }
      catch (XNATException exXNAT)
      {
         errorOccurred = true;
         errorMessage  = "Error interacting with XNAT.\n"
                         + exXNAT.getMessage();
      }
      catch (XMLException exXML)
      {
         errorOccurred = true;
         errorMessage  = "Error validating AIM XML file.\n"
                         + exXML.getMessage();
      }
      catch (DataFormatException exDF)
      {
         errorOccurred = true;
         errorMessage  = "Error validating extracting date or time from AIM XML file.\n"
                         + exDF.getMessage();
		}
		
      if (errorOccurred) return false; else return true;
		
   }
  
   
   @Override
   public void updateParseFile()
   {
      //TODO
   }
   
   
   private void populateStringFields()
   {
		/*
      if (mriw.outputType == MRIWOutput.BATCH_MODE)
         setStringField("Type", "Batch mode processing descriptor");

      if (mriw.outputType == MRIWOutput.RESULT_SET)
         setStringField("Type", "Result set");

      setStringField("Modality name",         mriw.inp.modality);
      setStringField("Modality subtype",      mriw.inp.subtype);
      
      setStringField("Converter class",       mriw.con.converterClass);
      setStringField("Converter keys",
                        mriw.getMRIWKeysAsString(mriw.con.converterKeyValue));
      setStringField("Converter values",
                        mriw.getMRIWValuesAsString(mriw.con.converterKeyValue));
      
      setStringField("Model class",           mriw.con.modelClass);
      setStringField("Model keys",
                        mriw.getMRIWKeysAsString(mriw.con.converterKeyValue));
      setStringField("Model values",
                        mriw.getMRIWValuesAsString(mriw.con.converterKeyValue));
      
      setStringField("Solver class",          mriw.con.solverClass);
      setStringField("Solver keys",
                        mriw.getMRIWKeysAsString(mriw.con.converterKeyValue));
      setStringField("Solver values",
                        mriw.getMRIWValuesAsString(mriw.con.converterKeyValue));
      
      setStringField("Curve extractor",       mriw.con.helpersCurveExtractor);
      setStringField("Onset locator",         mriw.con.helpersOnsetLocator);
      setStringField("ROI curve extractor",   mriw.con.helpersROICurveExtractor);
      setStringField("Contrast agent",        mriw.con.agentName);
      setStringField("Contrast agent volume", String.valueOf(mriw.con.agentVolume));
      setStringField("Patient weight",        String.valueOf(mriw.con.patientWeight));
      setStringField("Patient code"  ,        mriw.patientCode);
      setStringField("Measurement code",      mriw.measurementCode);
      setStringField("Imaging session date",  mriw.sessionDate);
      setStringField("Imaging session time",  mriw.sessionTime);
      setStringField("Slice location",        mriw.sliceLocation);
      
      setStringField("Computed maps present",
                        mriw.getMRIWMapNamesAsString(mriw.res.computedMaps));
      setStringField("Aggregate keys",
                        mriw.getMRIWKeysAsString(mriw.res.aggregateKeyValue));
      setStringField("Aggregate values",
                        mriw.getMRIWValuesAsString(mriw.res.aggregateKeyValue));
      
      setStringField("Provenance: program",   mriw.prov.programName);
      setStringField("Provenance: version",   mriw.prov.programVersion
                        + " build-id:"      + mriw.prov.programBuildID);
      setStringField("Provenance: arguments", "As specified in XML document");
      setStringField("Provenance: machine",   mriw.prov.platformRuntimeName
                        + " version:"       + mriw.prov.platformRuntimeVersion);
      setStringField("Provenance: platform",  mriw.prov.platformMachineOSName
                        + " version:"       + mriw.prov.platformMachineOSType
                        + " architecture:"  + mriw.prov.platformMachineArchitecture);
      setStringField("Provenance: user",      mriw.prov.creationUser);
		*/
   }
     
   
   @Override
   public void populateFields(MetadataPanel mdsp)
   {
      mdsp.populateJTextField("XNAT assessment ID", "Generated by XNAT on data upload");
      mdsp.populateJTextField("Associated project", XNATProject);
		/*
      mdsp.populateJTextField("MRIW_RECORD output date",   date);
      mdsp.populateJTextField("MRIW_RECORD output time",   time);
      mdsp.populateJTextField("Associated XNAT image session ID", XNATExperimentID);
      
      mdsp.populateJTextField("Note", "",  true);      
      mdsp.populateJTextField("Label","", true);
      
      mdsp.populateJTextField("Type", getStringField("Type"));
      
      
      for (String key : simpleEntries.keySet())
         mdsp.populateJTextField(key, getStringField(key));
      
      mdsp.populateJTextField("Provenance: program",   getStringField("Provenance: program"));
      mdsp.populateJTextField("Provenance: version",   getStringField("Provenance: version"));
      mdsp.populateJTextField("Provenance: arguments", getStringField("Provenance: arguments"));
      mdsp.populateJTextField("Provenance: user",      getStringField("Provenance: user"));
      mdsp.populateJTextField("Provenance: machine",   getStringField("Provenance: machine"));
      mdsp.populateJTextField("Provenance: platform",  getStringField("Provenance: platform"));
*/
   }


   @Override
   public void clearFields(MetadataPanel mdsp)
   {
      mdsp.populateJTextField("XNAT assessment ID",               "");
      mdsp.populateJTextField("Associated project",               "");
		/*
      mdsp.populateJTextField("MRIW_RECORD output date",                 "");
      mdsp.populateJTextField("MRIW_RECORD output time",                 "");
      mdsp.populateJTextField("Associated XNAT image session ID", "");
      mdsp.populateJTextField("Note",                             "", true);
      mdsp.populateJTextField("Label",                            "", true);
      mdsp.populateJTextField("Type",                             "");
      mdsp.populateJTextField("Provenance: program",              "");
      mdsp.populateJTextField("Provenance: version",              "");
      mdsp.populateJTextField("Provenance: arguments",            "");
      mdsp.populateJTextField("Provenance: user",                 "");
      mdsp.populateJTextField("Provenance: machine",              "");
      mdsp.populateJTextField("Provenance: platform",             "");
      */
      
      for (String key : simpleEntries.keySet())
         mdsp.populateJTextField(key, "");
   }


   
      
   /**
	 * Uploading data to XNAT is a two-stage process. First the data file
	 * is placed in the repository, then the metadata are placed in the SQL
	 * tables of the PostgreSQL database. This method attempts the repository
    * upload.
    *
	 * Note that we have to override the method in the parent class DataUploader.
	 * Loading an MRIW_RECORD output file is special because not only do we create an
	 * MRIW_RECORD element in the database (icr:regionSetData), but we also turn the ROI
	 * information into an RT-STRUCT file and upload that and deal with the
	 * calculated maps.
	 * @throws Exception 
	 */
   @Override
   public void uploadMetadata() throws Exception
   {
      errorOccurred = false;
          
      // -----------------------------------------------
      // Step 1: Upload the icr:mriwOutputData metadata.
      // -----------------------------------------------  
      
      if (XNATAccessionID == null)
         XNATAccessionID = getRootElement() + '_' + UIDGenerator.createShortUnique();
      
      String labelPrefix = getStringField("Label");
      
      Document metaDoc = createMetadataXml();
      if (errorOccurred) throw new XNATException(XNATException.FILE_UPLOAD,
                          "There was a problem in creating the metadata to "
                          + "metadata to describe the uploaded DICOM-RT "
                          + "structure set file.\n"
                          + getErrorMessage());
            
      try
      {
         RESTCommand = "/data/archive/projects/" + XNATProject
                       + "/subjects/"    + XNATSubjectID
                       + "/experiments/" + XNATExperimentID
                       + "/assessors/"   + XNATAccessionID;
         
         InputStream is = xnprf.doRESTPut(RESTCommand, metaDoc);
         int         n  = is.available();
         byte[]      b  = new byte[n];
         is.read(b, 0, n);
         String XNATUploadMessage = new String(b);
         
         if ((xnrt.XNATRespondsWithError(XNATUploadMessage)) ||
             (!XNATUploadMessage.equals(XNATAccessionID)))
         {
            errorOccurred = true;
            errorMessage  = XNATUploadMessage;
            throw new XNATException(XNATException.FILE_UPLOAD,
                          "XNAT generated the message:\n" + XNATUploadMessage);
         }
      }
      catch (Exception ex)
      {
         // Here we cater both for reporting the error by throwing an exception
         // and by setting the error variables. When performing the upload via
         // a SwingWorker, it is not easy to retrieve an Exception.
         errorOccurred = true;
         errorMessage = ex.getMessage();
         throw new XNATException(XNATException.FILE_UPLOAD, ex.getMessage());
      }
     
      
      // ---------------------------------------------------------------
      // Step 2: Create and upload the RT-STRUCT file.
      //         This is a multi-step process and will modify the XNAT
      //         database to add icr:roiData and icr:roiSetData objects.
      // ---------------------------------------------------------------
      
      RTStructureSetUploader rtsu = new RTStructureSetUploader(xnprf);
      rtsu.createTempRtStructFile(aim);
      rtsu.setUploadFile(new File(rtsu.getTempRtStructFilename()));
      
      // Note that this step duplicates some of the parsing work that has
      // just been performed on the MRIW_RECORD result set file, but the overhead is
      // probably worth it for some cleaner coding here.
      rtsu.prepareUpload();
      if (errorOccurred) throw new Exception(errorMessage);
      
      // The icr:roiSetData object that is created requires a label and a
      // description. If the structure set were uploaded manually, these
      // would be added by the user.
      rtsu.setStringField("Label",  this.getStringField("Label")+ "_ROI");
      rtsu.setStringField("Description", "ROI autogenerated from MRIW output file");
      rtsu.XNATAccessionID = getRootElement() + '_' + UIDGenerator.createShortUnique();
      
      try
      {
         rtsu.uploadMetadata();
         rtsu.uploadResourcesToRepository();
      }
      catch (Exception ex)
      {
         errorOccurred = true;
         errorMessage = ex.getMessage();
         throw new XNATException(XNATException.FILE_UPLOAD, ex.getMessage());
      }
   }
 
   
   
   /**
    * Create parts of the metadata XML file that are specific to this
    * particular subclass. Common parts of the XML file are handled by
    * various methods in the parent QCAssessmentUploader. Note that there
    * is no method output, because we are just adding to a work in progress.
    */
   @Override
   public void createSpecificMetadataXML()
   {
//      try
//      {
//         dppXML.delayedWriteEntity("outputType")
//                  .delayedWriteText(getStringField("Type"))
//               .delayedEndEntity();
//         
//         for (Map.Entry<String, String> entry : simpleEntries.entrySet())
//            dppXML.delayedWriteEntity(entry.getValue())
//                     .delayedWriteText(getStringField(entry.getKey()))
//                  .delayedEndEntity();
//      }
//      catch (IOException exIO){{reportError(exIO, "write MRIW specific elements");}}
   }
   
   
   
   
	/**
	 * Get the list of files containing the input data used in the creation of this
	 * XNAT assessor. 
	 * @return ArrayList of String file names
	 */
	@Override
   protected ArrayList<String> getInputCatEntries()
	{
		return new ArrayList<String>();
	}

	
	
   @Override
	public void createPrimaryResource()
	{
		StringBuilder description = new StringBuilder();
		description.append("AIM instance file created by ... ");
		
		primaryResource = new XnatResource(uploadFile,
		                                   "out",
		                                   "AIM_INSTANCE",
				                             "XML",
		                                   "EXTERNAL",
		                                   description.toString(),
				                             uploadFile.getName());
	}
   
	
	
	/**
    * Create additional thumbnail files and RTStruct_old file for upload with the
 AIM object.
    */
   @Override
   public void createAuxiliaryResources()
   {
      createInputCatalogueFile("DICOM", "RAW", "image referenced by AIM");
		
		String fileSep    = System.getProperty("file.separator");
      String filePrefix = XNATGUI.getHomeDir() + "temp" + fileSep + XNATAccessionID;
      try
      {
         ContourRendererHelper cr = new ContourRendererHelper();
         ArrayList<BufferedImage> thumbnails = cr.createImages();
			String thumbnailFile = filePrefix + "_AIM_ROI_thumbnail_";

         for (int i=0; i<thumbnails.size(); i++)
         {
            File outputFile = new File(thumbnailFile + i);
            ImageIO.write(thumbnails.get(i), "png", outputFile);
            
				XnatResource xr = new XnatResource(outputFile,
		                                         "out",
		                                         "AIM_ROI_THUMBNAIL",
				                                   "PNG",
		                                         "GENERATED",
		                                         "thumbnail image containing ROI contour",
				                                   outputFile.getName());
				auxiliaryResources.add(xr);
         }
      }
      catch (Exception ex)
      {
         reportError(ex, "create AIM thumbnail file");
      }
		
		DicomOutputStream dos = null;
		DicomObject       rts;
		try
		{
			dos = new DicomOutputStream(
						new FileOutputStream(
							new File(filePrefix + "AIM_RT-STRUCT.dcm")));
			rts = aim.createDICOM();
			dos.writeItem(rts, TransferSyntax.ExplicitVRLittleEndian);
		}
		catch (Exception ex)
		{
			reportError(ex, "create RT-STRUCT from AIM document");
		}
		finally
		{
			try {if (dos != null) dos.close();} catch (IOException exIO) {}
		}
   }
      
   
   
   
   @Override
   public String getRootElement()
   {
      return "AIMOutput";
   }
   
   
   @Override
   public String getRootComplexType()
   {
      return "icr:aimOutputData";
   }
   
   
   /**
    * Take a String variable in the form that is used by the MRIW_RECORD XML file and
 convert it to the XNAT date format yyyy-mm-dd.
    * @param dateTime
    * @return A String containing the date
    * @throws DataFormatException
    */
   public String convertToXNATDate(String dateTime) throws DataFormatException
   {
      String month;
      String day;
      String year;
      
      if (dateTime.length() < 24)
			throw new DataFormatException(DataFormatException.DATE, dateTime);
      
		month = dateTime.substring( 4,  7);
      day   = dateTime.substring( 8, 10);
      year  = dateTime.substring(20, 24);
      
      String[] months    = new String[] {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
      String[] m2Digit   = new String[] {"01", "02", "03", "04", "05", "06",
                                         "07", "08", "09", "10", "11", "12"};

      String month2Digit = null;
      for (int i=0; i<12; i++) if (months[i].equals(month)) month2Digit = m2Digit[i];
      if (month2Digit == null)
         throw new DataFormatException(DataFormatException.DATE, dateTime);

      return year + "-" + month2Digit + "-" + day.replaceFirst(" ", "0");
   }


   
   /**
    * Take a String variable in the form that is used by the MRIW_RECORD XML file and
 convert it to the XNAT date format yyyy-mm-dd.
    * @param dateTime
    * @return A String containing the date
    * @throws DataFormatException
    */
   public String convertToXNATTime(String dateTime) throws DataFormatException
   {
      return dateTime.substring(11, 19);
   }
   
   
   protected void debugContourOutput() throws Exception
   {

      ContourRendererHelper cr = new ContourRendererHelper();
      ArrayList<BufferedImage> bi = cr.createImages();
      for (int j=0; j<bi.size(); j++)
      {
         File outputFile = new File("/Users/simond/temp/ROI_test/ROI" + j
                                    + "/contour_" + j + ".png");
         outputFile.mkdirs();
         ImageIO.write(bi.get(j), "png", outputFile);
         }     
   }
   
}

