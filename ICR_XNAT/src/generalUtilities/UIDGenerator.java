/*
 * *******************************************************************
 * Copyright 2010 Institute of Cancer Research
 * 
 * This software is not currently licensed for redistribution.
 * All rights are reserved.
 *
 * @author Simon J Doran
 *
 * Java class: UIDGenerator.java
 * 
 * Main use is to create new UIDGenerator's for Java objects that are generated.
 *
 * First created on Jul 12, 2012 at 10:53:42 PM
 *********************************************************************
 */

package generalUtilities;

import org.dcm4che2.util.UIDUtils;
import java.lang.Math;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.text.SimpleDateFormat;
import java.util.Calendar;

public class UIDGenerator
{
   // Application ID list - will be extended over time.
   public static final int XNAT_DAO                 = 1;
   public static final int XNAT_DATA_UPLOADER       = 2;
   public static final int IDL                      = 3;
   
   // Object type ID list - will be extended over time.
   public static final int RT_STRUCT                = 1;
   public static final int ORIGINAL_UID_UNAVAILABLE = 2;
   public static final int PIXEL_DATA_REPLACED      = 3;
   
   // UIDGenerator type ID list - will be extended over time.
   public static final int SOPClassUID        = 1;
   public static final int SOPInstanceUID     = 2;
   public static final int StudyInstanceUID   = 3;
   public static final int SeriesInstanceUID  = 4;
   public static final int GENERIC_DATA_TYPE  = 5;
   
   

   /*
    * Create a new DICOM unique identifier for an object, using the method
    * described in Kamauu et al. J Digit Imaging. 2009 February; 22(1): 11â€“14. 
    * @return a String containing the UIDGenerator
    */
   public static String createNewDicomUID(int applicationID, int objectTypeID,
                                  int UIDTypeID)
   {
      /* TODO: The orgRoot is temporarily set to a value unique to the Royal
       * Marsden Hospital.
       * Possibilities include:
       * 
       * 1. In the installation process, require users to find and enter the
       *    appropriate value for their instution in a configuration file somewhere.
       * 
       * 2. Register a unique number for this software.
       * 
       * 3. Copy the org root from the original dataset on the basis that our
       *    base data is originally from that source.
       */
      String orgRoot = "1.2.826.0.1.534147.1";
      
      /* The locally unique suffix is generated according to the following pattern:
       * 
       * <descriptive portion> = <application ID>.<object type ID>.<UID type ID>
       * 
       * <uniqueness portion>  = <unique>.<time>.<count>
       *                         as generated by java.rmi.server.UIDGenerator and
       *                         described in the Kamauu paper.
       * 
       * Finally, Kamauu et al. add the UIDTypeID at the end. I am doing this
       * as well, but it seems unwarranted duplication of information. They do
       * not explain why.
       */
      String descriptive = "" + applicationID + "." + objectTypeID + "."
                              + UIDTypeID;
      
      String rmiUID = new java.rmi.server.UID().toString();
      int    pos1   = rmiUID.indexOf(":");
      int    unique = Math.abs(Integer.parseInt(rmiUID.substring(0, pos1), 16));
      int    pos2   = rmiUID.indexOf(":", pos1+1);
      long   time   = Long.parseLong(rmiUID.substring(pos1+1, pos2), 16);
      int    pos3   = rmiUID.indexOf(":", pos2+1);
      int    count  = 0x000000FFFF & Integer.parseInt(rmiUID.substring(pos2+1), 16);
      
      String uniqueness = unique + "." + time + "." + count;
      
      String finalUID = orgRoot + "." + descriptive + '.' + uniqueness + UIDTypeID;
      
      // Final check - this fails hard, rather than writing to a logger, because
      // this is a coding error that needs to be fixed straight away and we can't
      // carry on without proper UIDGenerator's.
      if (!UIDUtils.isValidUID(finalUID))
         throw new RuntimeException("Incorrect UID generation");
      
      return finalUID;
   }
   
  
   
   public static String createShortUnique()
   {
      InetAddress ip;
      long        macAddress = -1;
      String      uid;
      try
      {
         ip = InetAddress.getLocalHost();
         
         NetworkInterface network = NetworkInterface.getByInetAddress(ip);

         byte[] mac = network.getHardwareAddress();
         if (mac != null)
         {
            macAddress = 0;
            for (int i=0; i<mac.length; i++)
            {
               int b = 0xff & mac[mac.length - i - 1];
               macAddress += b * (long) Math.pow(256L, i);
            }
         }
      }
      
      // Do not fail if problem with getting MAC address, timing should still
      // give adequate uniqueness info.
      catch (Exception exIgnore){}

      // This construct with the do loop guarantees that timing portion cannot
      // be the same as for anything previously uploaded from this machine.
      long time;
      long t = System.currentTimeMillis();
      do   time = System.currentTimeMillis(); while (time == t);
      
      uid = (macAddress == -1) ? "zzzzzzzzz" :
                                 convertDecimalToIntegerBase(macAddress, 62);
      
      uid += "_" + convertDecimalToIntegerBase(time, 62);
                      
      String s = decodeShortUnique(uid);             
      return uid;             
   }
   
   
   public static String decodeShortUnique(String shortUID)
   {
      int  pos  = shortUID.indexOf("_");
      long mac  = convertIntegerBaseToDecimal(shortUID.substring(0, pos), 62);
      long time = convertIntegerBaseToDecimal(shortUID.substring(pos+1), 62);
      
      Calendar cal = Calendar.getInstance();
      cal.setTimeInMillis(time);
      SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
      
      return "Machine ID: " + Long.toHexString(mac) + " Timestamp: " +
              sdf.format(cal.getTime());     
   }
   
   
   /**
    * Convert a decimal integer to a character string in base b.
    * Sensible ASCII string values containing only alphanumerics are obtained
    * for all values of b from 2 to 62. I wrote this in order to extend the
    * standard Java code in Long.toString(long i, int radix) in order to cope
    * with a larger range of radix values, hence shortening the output string.
    * @param a integer containing decimal number to be converted
    * @param b integer containing the base
    * @return String containing base b conversion
    */
   public static String convertDecimalToIntegerBase(long a, int b)
   {
      StringBuilder s = new StringBuilder();
      while (a > 0)
      {
         int r    = (int) (a % b);
         char rch = (char) (r + 48 + (r>9 ? 7 : 0) + (r>35 ? 6 : 0));
         s.insert(0, rch);
         
         a = a / b;
      }
      
      return s.toString();
   }
   
   
   public static long convertIntegerBaseToDecimal(String s, int b)
   {
      long a  = 0;
      int  le = s.length();
      for (int i=0; i<le; i++)
      {
         char rch = s.charAt(le-i-1);
         int  r   = rch - 48 - ( rch>64 ? 7 : 0) - (rch>96 ? 6 : 0);
         a = (long) (a + r*Math.pow((double) b, (double) i));
      }
      
      return a;
   }
   
}


